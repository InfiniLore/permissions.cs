// ---------------------------------------------------------------------------------------------------------------------
// Imports
// ---------------------------------------------------------------------------------------------------------------------
using InfiniLore.Permissions.Generators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace InfiniLore.Permissions.Generators;

// ---------------------------------------------------------------------------------------------------------------------
// Code
// ---------------------------------------------------------------------------------------------------------------------
[Generator(LanguageNames.CSharp)]
public class PermissionsRepoGenerator : IIncrementalGenerator {

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValueProvider<ImmutableArray<PermissionsRepoDto>> data = context.SyntaxProvider
            .CreateSyntaxProvider(
                IsRepoClassCandidate,
                GatherPermissionsRepoDto
            )
            .Where(static x => x is not null)
            .Select(static (obj, _) => (PermissionsRepoDto)obj!)
            .Collect();
        
        context.RegisterSourceOutput(context.CompilationProvider.Combine(data), GenerateSources);
    }
    
    // ReSharper disable once ConvertIfStatementToReturnStatement
    private static bool IsRepoClassCandidate(SyntaxNode node, CancellationToken token) {
        if (node is not ClassDeclarationSyntax classDeclarationSyntax) return false;
        if (classDeclarationSyntax is not { AttributeLists.Count: > 0, Modifiers: var modifiers }) return false;
        return modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static PermissionsRepoDto? GatherPermissionsRepoDto(GeneratorSyntaxContext syntaxContext, CancellationToken token) {
        if ((ClassDeclarationSyntax)syntaxContext.Node is not {} classDeclaration) return null;
        if (ModelExtensions.GetDeclaredSymbol(syntaxContext.SemanticModel, classDeclaration) is not {} classSymbol) return null;
        
        ImmutableArray<AttributeData> attributes = classSymbol.GetAttributes();
        if (attributes.FirstOrDefault(attr => attr.AttributeClass?.Name == "PermissionsRepoAttribute") is not {} repoAttribute) return null;

        PermissionsPropertyDto[] properties = classDeclaration.Members
            .OfType<PropertyDeclarationSyntax>()
            .Where(prop => prop is { Type: PredefinedTypeSyntax { Keyword.Text: "string" } })
            .Select(PermissionsPropertyDto.FromPropertyDeclarationSyntax)
            .ToArray();
        
        bool obfuscate = repoAttribute.ConstructorArguments.FirstOrDefault().Value is int flagObfuscate && (flagObfuscate & 1) != 0;
        bool toUpperCase = repoAttribute.ConstructorArguments.FirstOrDefault().Value is int flagUppercase && (flagUppercase & 2) != 0;
        
        return new PermissionsRepoDto(
            className:classSymbol.Name,
            nameSpace:classSymbol.ContainingNamespace.ToDisplayString(), 
            properties:properties,
            obfuscate:obfuscate,
            toUpperCase:toUpperCase
        );
    }
    
    private static void GenerateSources(SourceProductionContext context, (Compilation compilation, ImmutableArray<PermissionsRepoDto> Right) source) {
        (_, ImmutableArray<PermissionsRepoDto> classDeclarations) = source;
        StringBuilder builder = new();
        using var sha256 = SHA256.Create();
        
        foreach (PermissionsRepoDto repoDto in classDeclarations) {
            builder.AppendLine("// <auto-generated />")
                .AppendLine($"namespace {repoDto.Namespace};")
                .AppendLine()
                .AppendLine($"public partial class {repoDto.ClassName} {{");

            foreach (PermissionsPropertyDto propertyDto in repoDto.Properties) {
                if (repoDto.ObfuscateOutput) propertyDto.ObfuscatePermissionName(sha256, repoDto.ToUpperCase);
                if (repoDto.ToUpperCase) propertyDto.ToUpperCase();
                builder.IndentLine(1, propertyDto.ToPropertyString());
            }
            
            builder.AppendLine("}");
            context.AddSource($"{repoDto.ClassName}.g.cs", builder.ToString());
            builder.Clear();
        }
    }
}
